<!DOCTYPE html>
<html>

<head>
    <meta charset='utf-8'>
    <meta http-equiv='X-UA-Compatible' content='IE=edge'>
    <title>Integrated Circuits</title>
    <meta name='viewport' content='width=device-width, initial-scale=1'>
    <!-- <link rel='stylesheet' type='text/css' media='screen' href='main.css'> -->
    <script src="https://cdn.jsdelivr.net/npm/vue"></script>
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">
    <script src='main.js'></script>
    <style>
        div#appContainer {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: auto;
        }
    </style>
</head>

<body>
    <div id="appContainer"></div>
    <script>
        const STATES = {
            LOW: false,
            HIGH: true
        };

        const configs = {
            canvas: {
                ic_width: 80,
                background: "#E0E0E0",
                margin_horizontal: 20,
                margin_vertical: 5,
                ic_background: "#FFFFFF",
                pin_width: 20,
                pin_height: 15,
                pin_vertical_margin: 5,
                pin_text_margin_horizontal: 5,
                pin_HIGH_bakcground: "#20F020",
                pin_LOW_bakcground: "#F02020"
            }
        };

        const PIN_TYPES = {
            INPUT: "input",
            OUTPUT: "output",
            GND: "GND",
            VCC: "VCC"
        };

        function drawPin(ctx, pins, rowIndex, isRight, textY, nameHorizontalMargin, pinNumberCenter, x, y, canvasWidth) {
            const pin = pins[isRight ? pins.length - rowIndex - 1 : rowIndex];
            const pinNumber = isRight ? pins.length - rowIndex : rowIndex + 1;
            const pinPos = [
                x,y,
                configs.canvas.pin_width,
                configs.canvas.pin_height
            ];

            ctx.fillStyle = pin.state || pin.type === PIN_TYPES.VCC ? configs.canvas.pin_HIGH_bakcground : configs.canvas.pin_LOW_bakcground;
            ctx.fillRect(...pinPos);
            ctx.strokeRect(...pinPos);

            ctx.fillStyle = "#000";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText(pinNumber, isRight ? canvasWidth - pinNumberCenter : pinNumberCenter, textY);

            ctx.textAlign = isRight ? "end" : "start";
            ctx.fillText(pin.name || pin.type, isRight ? canvasWidth - nameHorizontalMargin : nameHorizontalMargin, textY);
            pin.pos = { 
                x, 
                y, 
                h: configs.canvas.pin_width, 
                w: configs.canvas.pin_height 
            };
        }

        function drawICPins(pins, ctx, canvasWidth, canvasHeight, pinTotalHeight) {
            ctx.clearRect(0, 0, canvasWidth, canvasHeight);
            const horizontalMargin = configs.canvas.pin_width + configs.canvas.margin_horizontal;

            ctx.fillStyle = configs.canvas.ic_background;
            const icRect = [
                horizontalMargin,
                configs.canvas.margin_vertical,
                canvasWidth - 2 * horizontalMargin,
                canvasHeight - 2 * configs.canvas.margin_vertical
            ];
            ctx.fillRect(...icRect);
            ctx.strokeRect(...icRect);

            let pinVerticalStart = configs.canvas.pin_vertical_margin + configs.canvas.margin_vertical; //{ configs.canvas.margin_horizontal };
            let nameHorizontalMargin = configs.canvas.margin_horizontal + configs.canvas.pin_width + configs.canvas.pin_text_margin_horizontal;
            const pinNumberCenter = configs.canvas.margin_horizontal + configs.canvas.pin_width / 2;
            for (let pinIndex = 0; pinIndex < pins.length / 2; pinIndex++) {
                const textY = pinVerticalStart + configs.canvas.pin_height / 2;

                drawPin(ctx, pins, pinIndex, false, textY,nameHorizontalMargin, pinNumberCenter, 
                    configs.canvas.margin_horizontal,
                    pinVerticalStart, canvasWidth);


                drawPin(ctx, pins, pinIndex, true, textY, nameHorizontalMargin, pinNumberCenter,  
                    canvasWidth - configs.canvas.margin_horizontal - configs.canvas.pin_width,
                    pinVerticalStart, canvasWidth);

                pinVerticalStart += pinTotalHeight;
            }
        }

        function drawIC(definition, targetElement) {
            const pins = definition.pins;
            if (!pins || !pins.length || pins.length % 2) {
                console.log("Pin count not devidable by 2, " + JSON.stringify(pins));
                return;
            }
            const title = document.createElement("span");
            title.innerText = definition.name;
            targetElement.appendChild(title);

            const canvas = document.createElement("canvas");
            const pinTotalHeight = configs.canvas.pin_height + (2 * configs.canvas.pin_vertical_margin);
            const canvasHeight = (pins.length / 2) * pinTotalHeight + 2 * configs.canvas.margin_vertical;
            const canvasWidth = configs.canvas.ic_width + 2 * (configs.canvas.margin_horizontal + configs.canvas.pin_width);
            canvas.width = canvasWidth;
            canvas.height = canvasHeight;
            canvas.style.background = configs.canvas.background;
            targetElement.appendChild(canvas);

            const ctx = canvas.getContext("2d");

            drawICPins(pins, ctx, canvasWidth, canvasHeight, pinTotalHeight);

            const canvasLeft = canvas.offsetLeft;
            const canvasTop = canvas.offsetTop;

            canvas.onclick = function (event) {
                var x = event.pageX - canvasLeft,
                    y = event.pageY - canvasTop;

                pins.forEach(function (pin) {
                    if (pin.type !== PIN_TYPES.INPUT) {
                        return;
                    }
                    if (y > pin.pos.y && y < pin.pos.y + pin.pos.h && x > pin.pos.x && x < pin.pos.x + pin.pos.w) {
                        pin.state = !pin.state;
                    }
                });
                definition.update(pins);
                drawICPins(pins, ctx, canvasWidth, canvasHeight, pinTotalHeight);
            };
        }

        const container = document.getElementById("appContainer");

        const pins = [
            {
                name: "A1",
                type: PIN_TYPES.INPUT
            },
            {
                name: "B1",
                type: PIN_TYPES.INPUT
            },
            {
                name: "Y1",
                type: PIN_TYPES.OUTPUT
            },
            {
                name: "A2",
                type: PIN_TYPES.INPUT
            },
            {
                name: "B2",
                type: PIN_TYPES.INPUT
            },
            {
                name: "Y2",
                type: PIN_TYPES.OUTPUT
            },
            {
                type: PIN_TYPES.GND
            },
            {
                name: "Y3",
                type: PIN_TYPES.OUTPUT
            },
            {
                name: "A3",
                type: PIN_TYPES.INPUT
            },
            {
                name: "B3",
                type: PIN_TYPES.INPUT
            },
            {
                name: "Y4",
                type: PIN_TYPES.OUTPUT
            },
            {
                name: "A4",
                type: PIN_TYPES.INPUT
            },
            {
                name: "B4",
                type: PIN_TYPES.INPUT
            },
            {
                type: PIN_TYPES.VCC
            }
        ];

        function nand(a, b, y) {
            y.state = !(a.state && b.state);
        }

        function setStates(pins) {
            nand(pins[0], pins[1], pins[2]);
            nand(pins[3], pins[4], pins[5]);
            nand(pins[8], pins[9], pins[7]);
            nand(pins[11], pins[12], pins[10]);
        };

        setStates(pins);
        drawIC({ pins: pins, name: "74LS00 - NAND", update: setStates }, container);
    </script>
</body>

</html>